unit Common.DTOs.PessoaDTO;

interface

uses
  System.SysUtils,
  System.Generics.Collections,
  Common.DTOs.EnderecoDTO
  {$IFDEF SERVER}, Domain.Entities.Pessoa, Domain.Entities.Endereco{$ENDIF};

type
  TPessoaDTO = class
  private
    FIdpessoa : Int64;
    FFlnatureza : SmallInt;
    FDsdocumento : string;
    FNmprimeiro : string;
    FNmsegundo : string;
    FDtregistro : string;
    FEnderecos : TList<TEnderecoDTO>;
  public
    constructor Create;
    destructor Destroy; override;

    property IdPessoa : Int64    read FIdPessoa    write FIdPessoa;
    property FlNatureza : SmallInt read FFlNatureza  write FFlNatureza;
    property DsDocumento : string   read FDsDocumento write FDsDocumento;
    property NmPrimeiro : string   read FNmPrimeiro  write FNmPrimeiro;
    property NmSegundo : string   read FNmSegundo   write FNmSegundo;
    property DtRegistro : string   read FDtRegistro  write FDtRegistro;
    property Enderecos : TList<TEnderecoDTO> read FEnderecos;

    {$IFDEF SERVER}
    function ToEntity : TPessoa;
    class function FromEntity(const AEnt: TPessoa): TPessoaDTO; static;
    class function TryParseDate(const S: string; out ADate: TDate): Boolean; static;
    class function DateToStringSafe(const ADate: TDate): string; static;
    {$ENDIF}
  end;

implementation

uses
  System.DateUtils;

{ TPessoaDTO }

constructor TPessoaDTO.Create;
begin
  FEnderecos := TList<TEnderecoDTO>.Create;
end;

destructor TPessoaDTO.Destroy;
var
  LItem : TEnderecoDTO;
begin
  for LItem in FEnderecos do
    LItem.Free;
  FEnderecos.Free;
  inherited;
end;

{$IFDEF SERVER}
function TPessoaDTO.ToEntity: TPessoa;
var
  i : Integer;
  LEnd : TEndereco;
  LDT : TDateTime;
begin
  Result := TPessoa.Create;

  Result.IdPessoa    := IdPessoa;
  Result.FlNatureza  := FlNatureza;
  Result.DsDocumento := DsDocumento;
  Result.NmPrimeiro  := NmPrimeiro;
  Result.NmSegundo   := NmSegundo;

  if Trim(DtRegistro) = '' then
    LDT := 0
  else
    LDT := StrToDateDef(DtRegistro, 0);
  Result.DtRegistro := LDT;

  for i := 0 to FEnderecos.Count - 1 do
  begin
    LEnd := TEndereco.Create;
    LEnd.IdEndereco := FEnderecos[i].IdEndereco;
    LEnd.DsCep      := FEnderecos[i].DsCep;
    Result.Enderecos.Add(LEnd);
  end;
end;

class function TPessoaDTO.TryParseDate(const S: string;
  out ADate: TDate): Boolean;
begin
  Result := False;
  ADate  := 0;
  if S.Trim = '' then
    Exit(True);

  if TryStrToDate(S, ADate) then
    Exit(True);

  try
    if Length(S) = 10 then
    begin
      ADate := EncodeDate(
        StrToInt(Copy(S,1,4)),
        StrToInt(Copy(S,6,2)),
        StrToInt(Copy(S,9,2))
      );
      Exit(True);
    end;
  except
  end;
end;

class function TPessoaDTO.FromEntity(const AEnt: TPessoa): TPessoaDTO;
var
  LDto : TPessoaDTO;
  LEnd : TEndereco;
  LEndDto : TEnderecoDTO;
begin
  LDto := TPessoaDTO.Create;

  LDto.IdPessoa    := AEnt.IdPessoa;
  LDto.FlNatureza  := AEnt.FlNatureza;
  LDto.DsDocumento := AEnt.DsDocumento;
  LDto.NmPrimeiro  := AEnt.NmPrimeiro;
  LDto.NmSegundo   := AEnt.NmSegundo;

  if AEnt.DtRegistro = 0 then
    LDto.DtRegistro := ''
  else
    LDto.DtRegistro := DateToISO8601(AEnt.DtRegistro, False);

  for LEnd in AEnt.Enderecos do
  begin
    LEndDto := TEnderecoDTO.Create;
    LEndDto.IdEndereco := LEnd.IdEndereco;
    LEndDto.DsCep      := LEnd.DsCep;
    LDto.Enderecos.Add(LEndDto);
  end;

  Result := LDto;
end;

class function TPessoaDTO.DateToStringSafe(const ADate: TDate): string;
begin
  if ADate = 0 then
    Result := ''
  else
    Result := FormatDateTime('yyyy-mm-dd', ADate);
end;
{$ENDIF}

end.

